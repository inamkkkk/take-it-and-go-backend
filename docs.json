{
  "docs": [
    {
      "path": "package.json",
      "docs": "This file defines the metadata and dependencies for the 'takeitgo-backend' Node.js project. It serves as the entry point and configuration hub for the backend of the Take iT & Go peer-to-peer delivery platform.\n\n**Purpose:**\nTo manage project dependencies, define scripts for starting and developing the server, and provide essential metadata.\n\n**Responsibilities:**\n- Declares the project's name, version, and a descriptive overview.\n- Specifies the main entry file for the application ('server.js').\n- Defines scripts for common development tasks like starting the server ('start') and running in development mode with hot-reloading ('dev').\n- Lists all production and development dependencies required for the backend to function.\n\n**Key Functions/Sections:**\n- `name`: The identifier for the package.\n- `version`: The current version of the package.\n- `description`: A brief explanation of the project's purpose and features.\n- `main`: The primary JavaScript file to run when the package is executed.\n- `scripts`: Commands that can be executed using `npm` or `yarn`.\n  - `start`: Runs the application in production mode (`node server.js`).\n  - `dev`: Runs the application in development mode with `nodemon` for automatic restarts.\n  - `test`: Placeholder for test execution, currently indicates no tests are defined.\n- `dependencies`: Production dependencies needed for the application to run.\n  - `bcryptjs`: For password hashing.\n  - `cors`: To enable Cross-Origin Resource Sharing.\n  - `dotenv`: To load environment variables from a `.env` file.\n  - `express`: The web application framework for Node.js.\n  - `helmet`: For security middleware to set HTTP headers.\n  - `http-status-codes`: To provide standard HTTP status codes.\n  - `joi`: For object schema description and validation.\n  - `jsonwebtoken`: For creating and verifying JSON Web Tokens.\n  - `mongoose`: MongoDB object modeling tool.\n  - `socket.io`: Real-time, bidirectional event-based communication.\n  - `winston`: A flexible logger for Node.js.\n  - `xss-clean`: To sanitize user input to prevent XSS attacks.\n- `devDependencies`: Development dependencies used during the development lifecycle.\n  - `nodemon`: A utility that automatically restarts the server when file changes are detected.\n\n**TODOs:**\n- Implement actual tests in the `scripts.test` section instead of the placeholder message."
    },
    {
      "path": "server.js",
      "docs": "This file is the main entry point for the Node.js server. It sets up the HTTP server, connects to the database, initializes Socket.io for chat functionality, and handles various error and shutdown signals.\n\n**Purpose:**\n- Initialize and start the HTTP server.\n- Establish database connection.\n- Configure and integrate Socket.io for real-time chat.\n- Implement robust error handling and graceful shutdown mechanisms.\n\n**Responsibilities:**\n- Loading environment variables.\n- Creating an HTTP server instance using the Express application.\n- Connecting to the MongoDB database.\n- Setting up Socket.io communication.\n- Listening for incoming HTTP requests on a specified port.\n- Handling unhandled rejections and uncaught exceptions by logging errors and shutting down the server.\n- Responding to SIGTERM and SIGINT signals for graceful server termination.\n\n**Key Functions:**\n- `require('dotenv').config()`: Loads environment variables from a .env file.\n- `http.createServer(app)`: Creates an HTTP server that uses the provided Express app.\n- `connectDB()`: Initializes the connection to the MongoDB database.\n- `setupChatSocket(server)`: Sets up the Socket.io server attached to the HTTP server.\n- `server.listen(config.port, ...)`: Starts the HTTP server and makes it listen on the configured port.\n- `process.on('unhandledRejection', ...)`: Catches unhandled promise rejections.\n- `process.on('uncaughtException', ...)`: Catches synchronous errors that are not caught by try...catch blocks.\n- `process.on('SIGTERM', ...)` and `process.on('SIGINT', ...)`: Handles termination signals for graceful shutdown.\n\n**TODOs:**\n- Implement graceful shutdown for Socket.io connections (currently only the HTTP server is closed).\n- Ensure Socket.io connections are explicitly closed during SIGTERM and SIGINT signal handling."
    },
    {
      "path": "src/app.js",
      "docs": "This file sets up the main Express application. It initializes middleware for security, request parsing, logging, and rate limiting, and then defines the API routes and error handling. \n\n**Purpose:** \nTo configure and start the Express server, applying essential middleware and routing.\n\n**Responsibilities:**\n- Initialize the Express application.\n- Apply security middleware: Helmet, CORS, XSS sanitizer.\n- Configure request body parsing (JSON and URL-encoded).\n- Implement rate limiting to protect against abuse.\n- Integrate request logging (Morgan).\n- Mount all defined API routes.\n- Define a welcome route for the root path.\n- Implement a 404 Not Found handler.\n- Set up a global error handler.\n\n**Key Functions:**\n- `express()`: Initializes the Express application.\n- `app.use()`: Mounts middleware and routes.\n- `app.get()`: Defines a route handler for GET requests to the root path.\n\n**TODOs:**\n- Configure CORS more specifically if needed, e.g., allow only specific origins.\n- Implement rate limiting to protect against brute-force attacks (partially implemented, needs further review/configuration if specific strategies are required)."
    },
    {
      "path": "src/config/index.js",
      "docs": "This file handles application configuration by loading environment variables, validating them, and exporting a configuration object. It uses `dotenv` to load variables from a `.env` file and `Joi` for schema validation.\n\n**Purpose:**\n- To centralize and manage application configuration settings.\n- To ensure that required environment variables are present and have valid types.\n- To provide a structured way to access configuration values throughout the application.\n\n**Responsibilities:**\n- Loading environment variables from the `.env` file.\n- Defining a schema for expected environment variables using Joi.\n- Validating `process.env` against the defined schema.\n- Throwing an error if validation fails.\n- Exporting a well-structured configuration object with different sections (e.g., `env`, `port`, `mongoose`, `jwt`, `integrations`).\n\n**Key Functions/Features:**\n- `dotenv.config()`: Loads environment variables.\n- `Joi.object().keys({...})`: Defines the validation schema for environment variables, including types, required fields, defaults, and descriptions.\n- `envVarsSchema.prefs({ errors: { label: 'key' } }).validate(process.env)`: Validates the `process.env` object against the schema.\n- Error handling for validation failures.\n- Construction of the final configuration object, including logic for test environment specific MongoDB URL.\n\n**TODOs:**\n- Add validation for any new environment variables introduced in the future.\n- Add configuration for email integrations if they are implemented."
    },
    {
      "path": "src/config/db.js",
      "docs": {
        "purpose": "Handles the MongoDB database connection and disconnection for the application.",
        "responsibilities": [
          "Establishes a connection to the MongoDB database using Mongoose.",
          "Logs connection success or failure messages.",
          "Listens for and logs MongoDB disconnection events.",
          "Provides a function to gracefully disconnect from the MongoDB database."
        ],
        "key_functions": [
          {
            "name": "connectDB",
            "description": "Asynchronously connects to MongoDB using connection URL and options from the configuration. Logs the connection status and sets up an event listener for disconnections."
          },
          {
            "name": "disconnectDB",
            "description": "Asynchronously disconnects from the MongoDB database. Logs the disconnection status."
          }
        ],
        "todos": [
          "Implement graceful shutdown for the MongoDB connection.",
          "Consider using `mongoose.connection.on('disconnected', ...)` for logging.",
          "Refine error handling for connection failures, potentially implementing retry logic before exiting.",
          "Add a function to disconnect from MongoDB gracefully (this function already exists but might require further refinement or formalization)."
        ]
      }
    },
    {
      "path": "src/controllers/adminController.js",
      "docs": "This controller handles administrative functionalities, including user authentication, and retrieval of various system data like verifications, disputes, deliveries, and payment summaries. It uses JWT for admin authentication and relies on utility modules for API responses and logging.\n\n**Responsibilities:**\n- Authenticate admin users via email and password, returning a JWT upon successful login.\n- Provide endpoints to list and filter ID verification requests.\n- Provide endpoints to list and filter dispute records.\n- Provide endpoints to list and filter delivery/trip records.\n- Provide an aggregated overview of payment data, including summaries and filterable by date and status.\n\n**Key Functions:**\n- `login(req, res)`: Handles admin login, credential validation, and JWT generation.\n- `listVerifications(req, res)`: Retrieves and filters ID verification requests.\n- `listDisputes(req, res)`: Retrieves and filters dispute records.\n- `listDeliveries(req, res)`: Retrieves and filters delivery records.\n- `paymentsOverview(req, res)`: Aggregates and returns payment summary statistics.\n\n**TODOs:**\n- Load JWT secret key and token expiration time from environment variables.\n- Replace hardcoded admin user credentials and database lookups with actual implementations in the `login` function.\n- Implement actual database queries for `listVerifications`, `listDisputes`, `listDeliveries`, and `paymentsOverview` instead of using mock data.\n- Enhance filtering and pagination logic as per real-world requirements."
    },
    {
      "path": "src/controllers/authController.js",
      "docs": "This controller handles user authentication-related operations.\n\n**Responsibilities:**\n- User registration (signup)\n- User login (login)\n- Password reset initiation (forgotPassword)\n- Password reset execution (resetPassword)\n\n**Key Functions:**\n- `signup(req, res)`: Handles user registration. It calls `userService.createUser` to create the user and `authService.generateAuthTokens` to create authentication tokens. It returns the created user and tokens upon success.\n- `login(req, res)`: Handles user login. It calls `authService.loginUserWithEmailAndPassword` to authenticate the user and `authService.generateAuthTokens` to issue new tokens. It returns the authenticated user and tokens upon success.\n- `forgotPassword(req, res)`: Initiates the password reset process. It finds the user by email using `userService.getUserByEmail`, generates a reset token using `tokenService.generateResetPasswordToken`, and logs the event. It is intended to send an email with a reset link.\n- `resetPassword(req, res)`: Completes the password reset process. It verifies the reset token using `tokenService.verifyResetPasswordToken`, updates the user's password using `userService.updateUserById`, and invalidates the token using `tokenService.removeToken`. It returns a success message upon completion.\n\n**Error Handling:**\n- The controller catches errors and logs them using `logger.error`.\n- It checks if the error is an instance of `ApiError` to return a specific status code and error details; otherwise, it returns a generic error response.\n\n**TODOs:**\n- Implement email sending logic in `forgotPassword` for sending the password reset link.\n- Ensure `tokenService.removeToken` correctly handles token invalidation in `resetPassword`."
    },
    {
      "path": "src/controllers/chatController.js",
      "docs": "This file handles the real-time chat functionality using Socket.IO. It manages socket connections, authentication, message handling, user presence, and room management.\n\n**Purpose:** To provide a real-time chat experience between users.\n\n**Responsibilities:**\n- Establish and manage WebSocket connections.\n- Authenticate users connecting via Socket.IO.\n- Handle joining and leaving chat rooms.\n- Process and broadcast chat messages.\n- Implement typing indicators and read receipts.\n- Manage user presence (online/offline).\n- Log chat-related activities and errors.\n\n**Key Functions:**\n- `handleChat(socket, io)`: The main function that sets up event listeners for a new socket connection.\n  - **Authentication:** Verifies JWT token provided in the connection handshake query.\n  - **`joinRoom` event:** Allows users to join specific chat rooms (identified by `roomId`). It also fetches historical messages for that room.\n  - **`sendMessage` event:** Handles sending messages, saving them to the database via `chatService`, and broadcasting them to room participants.\n  - **`typing` / `stopTyping` events:** Broadcasts typing status to other users in the room.\n  - **`messageRead` event:** Handles marking messages as read (with a TODO for actual database update).\n  - **`disconnect` event:** Logs user disconnections.\n\n**TODOs:**\n- Initialize Notification service for offline messages.\n- Implement logic to verify if a user is allowed to join a specific room.\n- Implement sophisticated presence management (e.g., last seen).\n- Broadcast user offline status upon disconnection.\n- Update message status to 'read' in the database for `messageRead` event.\n- Refine the check for offline participants when sending notifications."
    },
    {
      "path": "src/controllers/disputeController.js",
      "docs": {
        "purpose": "Handles incoming requests related to disputes, including reporting new issues and retrieving existing ones. It interacts with the dispute service for business logic and uses API response utilities for consistent output.",
        "responsibilities": [
          "Validating input data for dispute-related operations using express-validator.",
          "Calling the appropriate dispute service methods to perform CRUD operations.",
          "Formatting success and error responses.",
          "Logging relevant information and errors."
        ],
        "key_functions": [
          {
            "name": "reportIssue",
            "description": "Handles the creation of a new dispute. It validates input, creates a dispute record via the service, and logs the action. TODOs exist for implementing notification logic.",
            "parameters": [
              "req: Express request object, expected to contain userId, tripId, type, description, and optional evidence in the body.",
              "res: Express response object."
            ],
            "returns": "A success response with the created dispute object or an error response."
          },
          {
            "name": "getDispute",
            "description": "Retrieves a specific dispute by its ID. It validates the ID, fetches the dispute from the service, and handles cases where the dispute is not found. TODOs exist for implementing authorization checks.",
            "parameters": [
              "req: Express request object, expected to contain the dispute ID in the URL parameters.",
              "res: Express response object."
            ],
            "returns": "A success response with the dispute object or an error response."
          }
        ],
        "todo_items": [
          "Implement logic to notify relevant parties (e.g., admin, involved users) when a new dispute is reported.",
          "Implement authorization logic to ensure only authorized users (e.g., involved user or admin) can view a specific dispute."
        ]
      }
    },
    {
      "path": "src/controllers/matchController.js",
      "docs": "## Match Controller\n\nThis controller handles requests related to finding matches between shippers and travelers for package delivery.\n\n### Purpose:\n\n- To facilitate the matching process by validating shipper requests and interacting with the `matchService` to find suitable travelers.\n\n### Responsibilities:\n\n- **Request Validation:** Validates incoming shipper requests using Joi schemas to ensure data integrity.\n- **Service Interaction:** Calls the `matchService` to perform the core matching logic.\n- **Response Formatting:** Formats successful responses with found matches or error responses for invalid requests or server errors.\n- **Logging:** Logs incoming requests, validation errors, successful matches, and server errors.\n\n### Key Functions:\n\n- **`findMatches(req, res)`:**\n    - **Purpose:** Finds potential traveler matches for a given shipper's delivery request.\n    - **Logic:**\n        1.  Validates the shipper's request payload (origin, destination, package details, desired delivery time) using the `findMatchesSchema`.\n        2.  If validation fails, returns a `BAD_REQUEST` response with the validation error message.\n        3.  If validation succeeds, it calls `matchService.findPotentialMatches()` with the validated request data.\n        4.  Responds with the list of found matches using a `successResponse` or an `INTERNAL_SERVER_ERROR` response if an error occurs during the matching process.\n    - **TODOs:**\n        - Define Joi schemas for request validation (partially done).\n        - Implement route-based matching logic within `matchService`.\n        - Integrate with Google Maps API for route calculations and spatial matching.\n        - Consider traveler's capacity, availability, and preferences.\n        - Apply business logic for optimal matching (e.g., shortest detour, best rating).\n        - Add other relevant package details to the validation schema (e.g., fragile, temperature-sensitive).\n        - Add fields for desired delivery time to the validation schema (partially done)."
    },
    {
      "path": "src/controllers/notificationController.js",
      "docs": "This controller handles the logic for sending notifications to users. It is responsible for receiving notification requests, processing them, and dispatching notifications through various channels, such as push notifications via Firebase Cloud Messaging (FCM) and saving notification records for in-app history.\n\nKey Functions:\n- `sendNotification`: An asynchronous function that orchestrates the notification sending process. It validates input, determines the notification channel, attempts to send the notification (e.g., via FCM), and logs the outcome.\n\nTODOs:\n- Import necessary libraries for input validation (e.g., Joi, express-validator).\n- Import and initialize Firebase Admin SDK for FCM integration.\n- Implement comprehensive input validation for the notification request payload.\n- Fetch user's FCM token from the database.\n- Integrate with Firebase Cloud Messaging (FCM) to send push notifications.\n- Implement logic to save notification records to the database for in-app history, ensuring persistence even if push notifications fail.\n- Potentially add logic for other notification channels like email or SMS."
    },
    {
      "path": "src/controllers/paymentController.js",
      "docs": "This controller handles payment-related operations for the application, focusing on escrow services. It acts as an intermediary between incoming API requests and the payment service, validating inputs and orchestrating payment gateway interactions.\n\nKey Responsibilities:\n- Managing the lifecycle of escrow payments, including creation, release, and refund.\n- Handling asynchronous events from payment gateways via webhooks.\n- Interfacing with the `paymentService` to interact with the database and payment gateways.\n- Providing appropriate HTTP responses based on operation success or failure.\n\nKey Functions:\n- `createEscrow(req, res)`: Initiates an escrow payment. It validates shipper, traveler, amount, and trip details, simulates payment gateway initiation, creates a 'pending' payment record, and returns necessary client-side data for payment completion.\n- `releaseFunds(req, res)`: Releases funds from escrow to the traveler. It validates payment ID and confirmation details, checks for confirmed delivery status, instructs the payment gateway to transfer funds, and updates the payment status to 'completed'.\n- `refundPayment(req, res)`: Processes a refund for a payment. It validates payment ID and reason, checks the payment status, instructs the payment gateway to issue a refund, and updates the payment status to 'refunded'.\n- `handleWebhook(req, res)`: Receives and processes events from payment gateways. It logs incoming webhooks, calls the `paymentService` to handle the event (e.g., update payment status based on gateway confirmation), and sends an acknowledgment response.\n\nTODOs:\n- Implement robust validation for all input parameters.\n- Integrate with actual payment gateway SDKs (Razorpay/Stripe) for `initiatePaymentGateway`, `transferFundsToTraveler`, and `processRefundGateway`.\n- Implement logic to check delivery confirmation in `releaseFunds`, potentially by interacting with a separate delivery/trip service.\n- Implement detailed error handling for various scenarios (e.g., payment gateway errors, database errors).\n- Enhance webhook handling to verify signatures from payment gateways for security.\n- Define and implement a comprehensive refund policy for `refundPayment`.\n- Potentially add more detailed logging and tracing for payment operations."
    },
    {
      "path": "src/controllers/trackingController.js",
      "docs": "This controller handles API endpoints related to trip tracking. It orchestrates interactions between the API request/response cycle and the tracking service.\n\n**Responsibilities:**\n- Receive and validate incoming requests for starting, stopping, and retrieving tracking data.\n- Delegate the core tracking logic to the `trackingService`.\n- Format responses to be consistent with the application's API response structure.\n- Log relevant information and errors.\n\n**Key Functions:**\n- `startTracking(req, res)`: Initiates GPS tracking for a given trip. It validates input, calls `trackingService.startTripTracking`, and sends a success or error response.\n- `stopTracking(req, res)`: Ends GPS tracking for a given trip. It validates input, calls `trackingService.stopTripTracking`, and sends a success or error response.\n- `getTracking(req, res)`: Retrieves historical GPS tracking data for a specific trip. It validates the `tripId` from parameters, calls `trackingService.getTripTrackingLogs`, and returns the logs or an appropriate error message.\n\n**TODOs:**\n- Implement comprehensive input validation for all endpoints.\n- Integrate authorization middleware in `getTracking` to ensure only authorized users (shipper, traveler, admin) can access tracking data.\n- Refine error handling in `startTracking` and `stopTracking` to return more specific HTTP status codes based on the nature of the error (e.g., 400 for validation errors, 500 for server-side issues)."
    },
    {
      "path": "src/controllers/verificationController.js",
      "docs": "## Verification Controller\n\nThis controller handles user identity verification processes, including uploading necessary documents and retrieving verification status.\n\n### Responsibilities:\n\n- **Document Upload:** Manages the secure upload of identification documents and selfies from users.\n- **Verification Status Retrieval:** Provides endpoints to check the current status of a user's verification.\n- **Input Validation:** Validates uploaded file types and sizes, and required parameters.\n- **Error Handling:** Gracefully handles errors during file upload, processing, and status retrieval.\n\n### Key Functions:\n\n- **`uploadDocuments(req, res)`:**\n  - Handles HTTP requests for uploading verification documents.\n  - Utilizes Multer middleware for file handling.\n  - Validates file types (JPEG, PNG, PDF for ID proof; JPEG, PNG for selfie) and sizes (up to 5MB).\n  - Interacts with `verificationService.submitVerificationDocuments` to create a verification record and store document paths.\n  - Responds with success or error messages.\n  - Includes logic to clean up uploaded files in case of an error during record creation.\n\n- **`getStatus(req, res)`:**\n  - Handles HTTP requests to retrieve a user's verification status.\n  - Validates the presence of `userId` from request parameters.\n  - Interacts with `verificationService.getVerificationStatus` to fetch the verification record.\n  - Returns the verification status (pending, approved, rejected) or an appropriate error if not found.\n\n### TODOs:\n\n- **Multer Configuration:** Ensure Multer is configured for production-ready file storage (e.g., cloud storage instead of local `uploads/`).\n- **Robust File Validation:** Implement more comprehensive validation for uploaded documents beyond basic type and size checks.\n- **Admin Review Triggering:** The `uploadDocuments` function assumes the service handles the notification of an admin review; this process might need explicit implementation or clearer delegation.\n- **File System Operations:** Import `fs` for file system operations, specifically for cleaning up temporary files during error handling in `uploadDocuments`.\n- **`userId` Validation in `getStatus`:** Enhance `userId` validation in `getStatus` for more robust error checking."
    },
    {
      "path": "src/middlewares/auth.js",
      "docs": "This file contains middleware functions for authentication and authorization using JSON Web Tokens (JWT).\n\n**Purpose:**\n- To secure API endpoints by verifying user identities and checking their permissions.\n\n**Responsibilities:**\n- **`authenticate` middleware:** Verifies JWTs from incoming requests, extracts user information, and attaches it to the request object.\n- **`authorize` middleware:** Checks if the authenticated user possesses the required roles to access a specific resource.\n\n**Key Functions:**\n- **`authenticate(req, res, next)`:**\n  - Extracts the JWT from the `Authorization` header.\n  - Verifies the token's signature and expiration using `jsonwebtoken.verify` and `config.jwt.secret`.\n  - If valid, decodes the JWT payload and attaches a user object (containing `id` and other decoded properties) to `req.user`.\n  - Responds with `401 Unauthorized` if no token is provided or if the token is invalid/expired.\n  - **TODO:** Consider fetching the full user object from the database within `authenticate` to ensure the user exists and has up-to-date information.\n\n- **`authorize(roles = [])`:**\n  - This is a middleware factory that returns an `async` middleware function.\n  - It takes an array of required `roles` as input.\n  - It checks if `req.user` and `req.user.id` exist (implying `authenticate` was used prior).\n  - It fetches the user from the database using `User.findById` to retrieve the most current role and check for account status.\n  - If specific `roles` are provided, it verifies if the fetched user's `role` is included in the allowed roles.\n  - If the user's role is insufficient, it responds with `403 Forbidden`.\n  - It attaches the full `user` object to `req.user` for subsequent use.\n  - Responds with `401 Unauthorized` if the user is not authenticated.\n  - Handles database errors during user fetching, responding with `500 Internal Server Error`.\n  - **TODO:** Unify error messages with `authenticate` if user authentication is a common failure point.\n  - **TODO:** Log authorization attempts for security auditing.\n  - **TODO:** Log internal server errors during authorization for debugging.\n\n**Dependencies:**\n- `jsonwebtoken` for JWT handling.\n- `http-status-codes` for HTTP status codes.\n- `../config` for application configuration (e.g., JWT secret).\n- `../utils/apiResponse` for standardized error responses.\n- `../models` for the `User` model."
    },
    {
      "path": "src/middlewares/errorHandler.js",
      "docs": "This file defines middleware functions for handling errors in the application. It centralizes error handling logic to ensure consistent response formats and logging.\n\n**Purpose:**\n- To catch unhandled errors that occur during the request-response cycle.\n- To format and send appropriate error responses to the client.\n- To log errors for debugging and monitoring purposes.\n\n**Responsibilities:**\n- Detects various error types (e.g., Mongoose CastError, duplicate key errors, Joi validation errors).\n- Sets appropriate HTTP status codes and error messages based on the error type.\n- Logs errors differently based on the environment (development vs. production).\n- Formats error responses using the `errorResponse` utility.\n\n**Key Functions:**\n- `errorHandler(err, req, res, next)`: The primary middleware function that handles errors. It inspects the `err` object, determines the appropriate status code and message, logs the error, and sends a JSON response.\n- `notFound(req, res, next)`: A middleware function specifically for handling requests to non-existent routes (404 errors). It logs a warning and sends a 404 Not Found response.\n\n**TODOs:**\n- Add more specific error handling for common error types like authentication and authorization errors.\n- Implement handling for custom error classes (e.g., `ApiError`) if they are used in the application."
    },
    {
      "path": "src/middlewares/morgan.js",
      "docs": "This middleware configures Morgan to log HTTP requests and responses with different formats and levels based on the status code. It customizes logging for success and error responses, integrating with the application's logger utility.\n\nResponsibilities:\n- Defines custom log tokens for error messages.\n- Conditionally formats log output based on the environment (production vs. others).\n- Sets up separate Morgan middleware instances for successful requests (status < 400) and error requests (status >= 400).\n- Streams logs to `logger.info` for success and `logger.error` for errors.\n\nKey Functions:\n- `morgan.token('message', ...)`: Defines a custom token to log the `errorMessage` from `res.locals`, defaulting to an empty string if not present.\n- `getIpFormat()`: Returns the IP address logging format string (`':remote-addr - '`) only in production environments.\n- `successResponseFormat`: Defines the log format for successful responses.\n- `errorResponseFormat`: Defines the log format for error responses, including the custom 'message' token.\n- `successHandler`: Morgan middleware configured to log successful requests (status < 400) to `logger.info`.\n- `errorHandler`: Morgan middleware configured to log error requests (status >= 400) to `logger.error`.\n\nTODOs:\n- Implement the 'message' token to log the error message from `res.locals.errorMessage`. If `res.locals.errorMessage` is not present, log an empty string.\n- Implement the `getIpFormat` function to conditionally return ':remote-addr - ' based on the environment. Production environment should include the IP address, while others should not.\n- Define the `successResponseFormat` string. It should include the IP format (if applicable), HTTP method, URL, status code, and response time.\n- Define the `errorResponseFormat` string. It should include the IP format (if applicable), HTTP method, URL, status code, response time, and the custom 'message' token.\n- Create and configure the `successHandler` middleware using Morgan. It should skip logs for responses with status codes >= 400 and stream logs to `logger.info`.\n- Create and configure the `errorHandler` middleware using Morgan. It should skip logs for responses with status codes < 400 and stream logs to `logger.error`.\n- Export the `successHandler` and `errorHandler`."
    },
    {
      "path": "src/middlewares/validator.js",
      "docs": "This middleware is responsible for validating incoming request data (parameters, query strings, and request bodies) using Joi schemas.\n\n**Purpose:** To ensure that incoming request data conforms to predefined structures and types before it is processed by the application's business logic, thereby preventing invalid data from causing errors or security vulnerabilities.\n\n**Responsibilities:**\n- Dynamically selects Joi validation schemas based on the HTTP method of the incoming request.\n- Validates `params`, `query`, and `body` of the request against the corresponding parts of the selected schema.\n- Collects all validation errors if any occur.\n- If validation errors are found, it sends a `400 Bad Request` response with a formatted error message.\n- If validation is successful, it assigns the validated values back to the `req` object and proceeds to the next middleware or route handler.\n\n**Key Functions:**\n- `validate(schemas)`: A higher-order function that takes an object of Joi schemas, keyed by HTTP method (e.g., `get`, `post`, `put`), and returns the actual middleware function.\n- The returned middleware function (`(req, res, next) => {...}`):\n    - Determines the request method.\n    - Looks up the schema for that method.\n    - If a schema exists, it prepares a `validationTarget` object containing `params`, `query`, and `body` from the request if defined in the schema.\n    - Iterates through `params`, `query`, and `body` (if defined in the schema) and validates them using Joi.\n    - Accumulates validation errors.\n    - If errors are present, sends a `400 BAD_REQUEST` response.\n    - If no errors, it merges validated values into the `req` object and calls `next()`.\n\n**TODOs:**\n- Refactor validation logic for better dynamic handling of different HTTP methods and their schemas, possibly mapping methods to specific Joi schemas more elegantly.\n- Consider adding a warning or error when a schema is expected for a method but is not found.\n- Ensure validation is selective, only applying Joi to request parts (`params`, `query`, `body`) explicitly defined in the schema, rather than merging all available parts.\n- Explore using `Joi.alternatives()` or `Joi.object().concat()` for more complex schema merging scenarios if needed.\n- Assign validated values back to the request object in a more structured way (e.g., `req.validatedParams`, `req.validatedQuery`) to avoid potential overwrites and improve clarity, instead of directly merging them."
    },
    {
      "path": "src/models/Chat.js",
      "docs": "This file defines the Mongoose schema and model for 'Chat' messages.\n\n**Purpose:** To represent and manage chat messages within the application.\n\n**Responsibilities:**\n- Stores sender and receiver user IDs.\n- Associates messages with a specific 'Delivery' (trip) if applicable.\n- Stores the message content and timestamp.\n- Tracks whether a message has been read.\n\n**Key Functions:**\n- Defines the structure of a chat message using `chatSchema`.\n- Creates a Mongoose model named 'Chat' based on the schema.\n\n**TODOs:**\n- No explicit TODOs are present in the code. Further enhancements might include adding chat room functionality, message editing/deletion, or more sophisticated read receipts."
    },
    {
      "path": "src/models/Delivery.js",
      "docs": "This file defines the Mongoose schema and model for a Delivery. It represents a shipment request from a shipper to be picked up and delivered by a traveler. Key responsibilities include storing details about the shipper, traveler (once assigned), origin and destination addresses with coordinates, package information, delivery status, fare, and estimated delivery date.  \n\nKey Fields:\n- `shipperId`: Reference to the user who initiated the delivery request.\n- `travelerId`: Reference to the user assigned to transport the package (optional, as it can be null initially).\n- `origin`: Details of the pickup location (address and coordinates).\n- `destination`: Details of the delivery location (address and coordinates).\n- `package`: Information about the item to be delivered (description, weight, dimensions).\n- `status`: The current state of the delivery, with predefined enum values.\n- `fare`: The agreed-upon price for the delivery.\n- `estimatedDeliveryDate`: The expected date of delivery.\n- `createdAt`: Timestamp for when the delivery record was created.\n- `shipperRating`: Rating provided by the shipper for the traveler (optional).\n- `travelerRating`: Rating provided by the traveler for the shipper (optional).\n- `currentLocation`: Real-time tracking information for the delivery (address and coordinates).\n\nTODOs:\n- Add package details (size, weight, description) - *Partially implemented, needs review for completeness.*\n- Add rating fields for both shipper and traveler after delivery - *Partially implemented, needs review.*\n- Add fields for tracking the delivery in real-time (e.g., current location) - *Partially implemented, needs review.*\n"
    },
    {
      "path": "src/models/Dispute.js",
      "docs": "Represents a dispute related to a delivery or payment. \n\n**Purpose:** \nTo model and manage disputes raised by users regarding their deliveries or payment issues.\n\n**Responsibilities:**\n- Stores information about the user and trip involved in the dispute.\n- Categorizes the dispute type (e.g., payment_issue, delivery_issue).\n- Allows users to provide a detailed description and upload evidence.\n- Tracks the status of the dispute (open, in_review, resolved, escalated, closed).\n- Records who resolved the dispute and the details of the resolution.\n\n**Key Functions:**\n- `mongoose.model('Dispute', disputeSchema)`: Creates the Dispute Mongoose model.\n- `disputeSchema.pre('save', ...)`: Implements a pre-save hook to ensure that `resolvedBy` and `resolutionDetails` are provided when the dispute status is 'resolved'.\n\n**TODOs:**\n- The `resolvedBy` and `resolutionDetails` fields have commented-out `required` properties. These should be uncommented and potentially handled more robustly within the pre-save hook or application logic if strict enforcement is needed at the schema level before saving.\n- The pre-save hook currently throws an `Error`. Consider using Mongoose's validation mechanisms for more integrated error handling.\n- Ensure that the `User` and `Delivery` models referenced by `userId` and `tripId` are properly defined and available."
    },
    {
      "path": "src/models/GPSLog.js",
      "docs": "## GPSLog Model\n\n**Purpose:** This model represents a single GPS log entry, capturing location data for a specific trip and user at a given point in time.\n\n**Responsibilities:**\n*   Stores geographical coordinates (longitude and latitude).\n*   Associates GPS logs with specific `Delivery` trips and `User`s.\n*   Records the `timestamp` of the GPS reading.\n*   Optionally stores `accuracy`, `speed`, and `altitude` of the GPS reading.\n\n**Key Functions:**\n*   **`mongoose.model('GPSLog', gpsLogSchema)`:** Creates a Mongoose model for GPS log entries, enabling database operations.\n*   **`gpsLogSchema.index({ 'location.coordinates': '2dsphere' })`:** Creates a 2dsphere geospatial index on the `location.coordinates` field, optimizing queries for geographical data, particularly useful for real-time tracking visualizations.\n\n**TODOs:**\n*   Consider adding `additional fields` that might be relevant for a GPS log, such as `accuracy`, `speed`, `altitude`, etc. (These have been added as optional fields in the current schema but could be further refined or made required if necessary).\n*   Further explore the necessity and implementation of real-time tracking visualization using the `2dsphere` index."
    },
    {
      "path": "src/models/Payment.js",
      "docs": "## Payment Model\n\n**Purpose:** This model represents a financial transaction within the application, linking shippers, travelers, and delivery trips.\n\n**Responsibilities:**\n- Stores details of payments made between shippers and travelers for deliveries.\n- Tracks payment status, amounts, currency, and transaction identifiers.\n- Manages payment gateway information and specific payment details.\n- Provides methods for confirming, disputing, and refunding payments.\n\n**Key Functions:**\n- `confirmPayment()`: Marks the payment as 'completed' and includes placeholder logic for fund release.\n- `disputePayment(reason)`: Sets the payment status to 'disputed' and logs the dispute reason.\n- `refundPayment(refundAmount, reason)`: Sets the payment status to 'refunded', validates the refund amount, and records refund details.\n\n**TODOs:**\n- Add a field to track confirmation status from both shipper and traveler.\n- Add fields for payment method and associated details (e.g., last 4 digits of card), ensuring secure handling.\n- Implement actual fund release logic in `confirmPayment()`.\n- Integrate with payment gateways for actual refund processing in `refundPayment()`.\n- Potentially add a field to store dispute reasons if not handled within `paymentDetails`.\n- Consider robust error handling and validation for payment operations."
    },
    {
      "path": "src/models/User.js",
      "docs": "Defines the Mongoose schema for a User. This model represents users in the system with properties like email, phone number, password, role, and verification statuses. It handles password hashing using bcryptjs and includes methods for password comparison. \n\n**Responsibilities:**\n- Define the structure and data types for user information.\n- Enforce data validation rules for email, phone, and password.\n- Automatically hash passwords before saving.\n- Provide a method to compare a given password with the stored hashed password.\n\n**Key Functions:**\n- `pre('save')`: Hooks into the save operation to hash the user's password before it's persisted.\n- `methods.isPasswordMatch(password)`: An instance method that compares a provided plain-text password with the user's stored hashed password.\n\n**TODOs:**\n- Improve phone number validation to robustly handle international formats, potentially using 'libphonenumber-js'.\n- Enhance password complexity requirements (e.g., adding checks for special characters, consecutive characters).\n- Add fields for storing verification tokens (email and phone) and their expiration times.\n- Add a field to track the last login timestamp."
    },
    {
      "path": "src/models/Notification.js",
      "docs": "This file defines the Mongoose schema for a Notification model. \n\n**Purpose:** To represent and manage various types of notifications within the application, such as delivery updates, payment status changes, new matches, chat messages, system alerts, admin messages, verification statuses, and dispute updates.\n\n**Responsibilities:**\n- Stores notification details including the recipient user, notification type, message content, and any associated data.\n- Tracks the read status and timestamp of notifications.\n- Provides a structured way to create and query notifications.\n\n**Key Functions:**\n- `mongoose.model('Notification', notificationSchema)`: Creates the Mongoose model for notifications.\n- `notificationSchema.pre('save', ...)`: A pre-save hook that automatically sets the `readAt` timestamp when a notification is marked as read and `readAt` hasn't been set yet.\n\n**TODOs:**\n- The schema definition for `readAt` already exists and is initialized to `null`.\n- The pre-save hook for setting `readAt` is also implemented.\n- Consider if any other automatic updates or validations are needed for notifications."
    },
    {
      "path": "src/models/Verification.js",
      "docs": "Represents the user verification process within the system. It stores information related to a user's identity verification, including uploaded documents, status of the review, and associated metadata.\n\nResponsibilities:\n- Stores user verification data.\n- Tracks the status of the verification process.\n- Records details of submitted documents and reviewer actions.\n\nKey Functions/Properties:\n- `userId`: References the user undergoing verification.\n- `documentType`: Type of document submitted (e.g., 'national_id', 'passport').\n- `documentUrls`: Array of URLs pointing to the uploaded identity documents.\n- `selfieUrl`: URL to the user's selfie, if required.\n- `status`: Current state of the verification ('pending', 'in_review', 'verified', 'rejected').\n- `rejectionReason`: Explanation if the verification was rejected.\n- `submittedAt`: Timestamp when the verification was submitted.\n- `reviewedAt`: Timestamp when the verification was reviewed.\n- `reviewedBy`: References the admin user who performed the review.\n\nTODOs:\n- Implement a virtual field to easily retrieve the associated `User` object.\n- Add a pre-save hook to automatically set `reviewedAt` when the `status` changes to 'verified' or 'rejected'."
    },
    {
      "path": "src/routes/adminRoutes.js",
      "docs": "Documentation generation failed"
    },
    {
      "path": "/src/routes/authRoutes.js",
      "docs": {
        "purpose": "Handles all authentication-related API routes, including user signup, login, and password management. It leverages middleware for validation and controllers for business logic.",
        "responsibilities": [
          "Define API endpoints for authentication (signup, login, forgot password, reset password).",
          "Integrate input validation using a Joi schema and a custom `validate` middleware.",
          "Delegate actual authentication and authorization logic to the `authController`.",
          "Export an Express router instance to be used in the main application."
        ],
        "keyFunctions": [
          {
            "name": "express.Router()",
            "description": "Creates a new router object that acts as a modular, mountable route handler."
          },
          {
            "name": "validate(schema)",
            "description": "Middleware function that takes a Joi schema and validates the incoming request body against it. It throws an error if validation fails."
          },
          {
            "name": "authController.signup",
            "description": "Controller function responsible for handling user registration logic."
          },
          {
            "name": "authController.login",
            "description": "Controller function responsible for handling user login and token generation."
          },
          {
            "name": "authController.forgotPassword",
            "description": "Controller function for initiating the password reset process."
          },
          {
            "name": "authController.resetPassword",
            "description": "Controller function for completing the password reset process with a new password."
          }
        ],
        "todos": [
          "Implement logout functionality.",
          "Implement functionality for refreshing access tokens.",
          "Implement email verification flow for new user accounts."
        ],
        "validationSchemas": {
          "signupSchema": "Validates user signup request, requiring email, phone (E.164 format), and password (min 8 chars, alphanumeric). Allows optional role ('shipper' or 'traveler').",
          "loginSchema": "Validates user login request, requiring email and password.",
          "forgotPasswordSchema": "Validates forgot password request, requiring email.",
          "resetPasswordSchema": "Validates reset password request, requiring a token and a new password (min 8 chars, alphanumeric)."
        }
      }
    },
    {
      "path": "src/routes/disputeRoutes.js",
      "docs": {
        "purpose": "This file defines the API routes for managing dispute-related operations within the application. It handles reporting new disputes, retrieving specific dispute details, and listing disputes.",
        "responsibilities": [
          "Define API endpoints for dispute management.",
          "Implement input validation for dispute-related requests.",
          "Integrate authentication and authorization middleware.",
          "Delegate core logic to the dispute controller."
        ],
        "keyFunctions": [
          {
            "name": "POST /report",
            "description": "Reports a new issue or dispute. Requires user authentication and validates the request body against the `reportIssueSchema` before calling `disputeController.reportIssue`.",
            "middleware": [
              "authenticate",
              "validate(reportIssueSchema)"
            ]
          },
          {
            "name": "GET /:id",
            "description": "Retrieves the details of a specific dispute by its ID. Requires user authentication and validates the `id` parameter against the `getDisputeSchema` before calling `disputeController.getDispute`.",
            "middleware": [
              "authenticate",
              "validate(getDisputeSchema)"
            ]
          },
          {
            "name": "GET /",
            "description": "Lists disputes. Requires authentication and authorization for 'admin' or 'user' roles. Optionally filters disputes by `userId` and `tripId` via query parameters, validating against `listDisputesSchema` before calling `disputeController.listDisputes`.",
            "middleware": [
              "authenticate",
              "authorize(['admin', 'user'])",
              "validate(listDisputesSchema)"
            ]
          }
        ],
        "TODOs": [
          "Add a route to list all disputes, with optional filtering by userId and tripId.",
          "Ensure the listing route is protected by `authenticate` and `authorize` middleware."
        ]
      }
    },
    {
      "path": "/matchRoutes",
      "docs": "Handles routes related to finding, viewing, and managing matches between shippers and drivers.\n\nResponsibilities:\n- Provide endpoints for finding potential matches based on trip details.\n- Allow authenticated and authorized users (shippers and drivers) to access match information.\n- Enable drivers to update the status of a match.\n\nKey Functions:\n- `POST /find`: Authenticates the user as a shipper, authorizes them, validates the request body using `findMatchesSchema`, and calls `matchController.findMatches` to find potential matches.\n- `GET /:id`: Authenticates and authorizes users as shipper or driver, retrieves a specific match by its ID using `matchController.getMatchById`.\n- `PUT /:id/status`: Authenticates and authorizes users as drivers, updates the status of a specific match by its ID using `matchController.updateMatchStatus`.\n- `GET /shipper`: Authenticates and authorizes users as shippers, retrieves a list of matches relevant to the shipper using `matchController.getShipperMatches`.\n- `GET /driver`: Authenticates and authorizes users as drivers, retrieves a list of matches relevant to the driver using `matchController.getDriverMatches`.\n\nTODOs:\n- Implement route for fetching a specific match by ID.\n- Implement route for accepting/rejecting a match (for drivers).\n- Implement route for getting a list of matches for a shipper.\n- Implement route for getting a list of matches for a driver."
    },
    {
      "path": "src/routes/notificationRoutes.js",
      "docs": "## Notification Routes\n\nThis module defines the API endpoints for managing user notifications.\n\n**Purpose:** To handle the creation, retrieval, and marking as read of notifications for users within the application.\n\n**Responsibilities:**\n- Define API endpoints for sending, retrieving, and updating notification statuses.\n- Integrate with authentication and authorization middleware to secure endpoints.\n- Utilize a validation middleware to ensure incoming request data conforms to predefined schemas.\n- Delegate core business logic to the `notificationController`.\n\n**Key Functions/Routes:**\n- `POST /send`: Allows authorized users (admin, shipper, traveler) to send notifications. Requires `userId`, `type`, `message`, and optional `data` in the request body.\n- `GET /user/:userId`: Retrieves all notifications for a specific user. Requires user authentication and authorization for shipper, traveler, or admin roles.\n- `PATCH /:notificationId/read`: Marks a specific notification as read. Requires user authentication and authorization for shipper or traveler roles.\n\n**Validation Schemas:**\n- `sendNotificationSchema`: Validates the payload for sending notifications, ensuring `userId`, `type`, and `message` are present and correctly formatted, and that `type` is one of the allowed values.\n- `getUserNotificationsSchema`: Validates the `userId` parameter for fetching user-specific notifications.\n- `markAsReadSchema`: Validates the `notificationId` parameter for marking a notification as read.\n\n**TODOs:**\n- Potentially add more granular notification types or data structures as needed.\n- Consider implementing routes for deleting notifications or clearing all notifications."
    },
    {
      "path": "src/routes/paymentRoutes.js",
      "docs": "Documentation generation failed"
    },
    {
      "path": "src/routes/trackingRoutes.js",
      "docs": "This file defines the API routes for tracking functionalities. It handles starting, stopping, and retrieving tracking data for trips. It also includes a WebSocket endpoint for real-time location updates.\n\n**Responsibilities:**\n- Define API endpoints for tracking.\n- Implement request validation for tracking operations.\n- Integrate authentication and authorization middleware.\n- Handle WebSocket connections for real-time location broadcasting.\n\n**Key Functions:**\n- `POST /start`: Initiates tracking for a given trip. Requires `tripId` and `userId` in the body. Protected by `authenticate` and `authorize` (traveler role).\n- `POST /stop`: Stops tracking for a given trip. Requires `tripId` and `userId` in the body. Protected by `authenticate` and `authorize` (traveler role).\n- `GET /:tripId`: Retrieves tracking status or history for a specific trip. Requires `tripId` in params. Protected by `authenticate` and `authorize` (shipper, traveler, admin roles).\n- `WS /live/:tripId`: Establishes a WebSocket connection for real-time location updates. Requires `tripId` in params. Protected by `authenticate` and `authorize` (traveler role). Listens for location updates and broadcasts them.\n\n**TODOs:**\n- Initialize and configure WebSocket server if not done globally (currently assumes `io` is accessible).\n- Implement the actual logic for `trackingController.startTracking`, `trackingController.stopTracking`, and `trackingController.getTracking`.\n- Refine WebSocket integration: If `io` is not globally available, adjust how it's accessed or initialized.\n- Implement WebSocket message handling logic within the `/live/:tripId` route for processing location updates and broadcasting them to subscribed clients.\n- Implement WebSocket subscription/unsubscription logic for managing active connections to specific trips."
    }
  ]
}